<!DOCTYPE html>
<!-- saved from url=(0050)https://fiddle.jshell.net/iEason/p4xxxz3s/37/show/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="robots" content="noindex, nofollow">
  <meta name="googlebot" content="noindex, nofollow">
  <script type="text/javascript" src="./jquery-1.11.0.js"></script>
    <link rel="stylesheet" type="text/css" href="./result-light.css">
      <script type="text/javascript" src="./jcanvas.js"></script>
  <style type="text/css">
    /*
    Please only use the following colors in your assignments. 
    
    // Grays
    lightest-gray:             #FBFBFB;
    lighter-gray:              #D8D8D8;
    light-gray:                #CCCCCC;
    gray:                      #888888;
    darker-gray:               #666666;
    darkest-gray:              #333333;

    // Oranges
    lightest-orange:           #FFDAC1;
    lighter-orange:            #F9D8BC;
    light-orange:              #FFB789;
    pale-orange:               #E8B493;
    accent-orange:             #E68142;
    orange:                    #c60;
    dark-orange:               #AB4600;

    // Blues
    lighter-blue:              #87ADD2;
    light-blue:                #6685A8;
    dark-blue:                 #5780A6;
    darker-blue:               #576E91;

    // Greens
    green:                     #738033;

    // Reds
    light-red:                 #FF4949;
    red:                       #BB0404;
    dark-red:                  #880000;

    // Yellows
    light-yellow:              #FFD364;
    yellow:                    #EAB51F;
    dark-yellow:               #D39F0D;

    // Black & white
    black:                     #000000;
    white:                     #FFFFFF;
*/
 body {
    background-color: white;
}
.assignment-container {
    border: 1px solid #333333;
    height: 500px;
    margin-bottom: 10px;
    width: 650px;
}
.button-container {
    overflow: visible;
    white-space: nowrap;
    width: 650px;
    word-wrap: none;
}
.container-label {
    font-size: 20px;
    display: block;
}
.example-button {
    background-color: #c60;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 16px;
    height: 30px;
    margin: 0 2px 5px 0;
    white-space: nowrap;
    width: 100px;
}
.reset-button, .run-button {
    background-color: #c60;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 18px;
    height: 40px;
    margin-bottom: 5px;
    width: 100px;
}
.reset-button:hover, .run-button:hover {
    background-color: #AB4600;
}
.textarea-style {
    height: 170px;
    margin-bottom: 15px;
    width: 230px;
}
.textarea-wide {
    width: 400px;
}
/* 
  Add any additional CSS rules below 
  Please avoid using !important in any rules
*/
 .pause-button {
    background-color: #c60;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 18px;
    height: 40px;
    margin-bottom: 5px;
    width: 100px;
}
  </style>

  <title> by iEason</title>

<script type="text/javascript">//<![CDATA[
$(window).load(function(){
/*
  Two javascript libraries have been included for your use 
  Please do not use any other external javascript library
  
  Included libraries:
     - jQuery
     - jCanvas

  Documentation / references:
  References: 
     - HTML/CSS/JavaScript
     http://www.w3schools.com/
     https://developer.mozilla.org/en-US/Learn/HTML
     - jQuery
     http://learn.jquery.com/
     http://www.w3schools.com/jquery/default.asp
     
  API:
     - jQuery
     http://api.jquery.com/
     - jCavanas  
     http://projects.calebevans.me/jcanvas/docs/
*/

// Stores the id of the canvas element
this.canvasId = 'drawingCanvas';

// Stores the id of the assignment container
this.divContainerId = 'assignmentContainer';

// Stores the id of the input textarea
this.inputTextareaId = 'inputData';

// Stores the id of the input textarea
this.outputTextareaId = 'outputData';

// Gets a reference to the canvas
this.$canvas = $('#' + this.canvasId);

// Sets default spacing to 0
this.spacing = 0;

// Sets a reference to the global scope
var self = this;

// Initializes listeners and resets any values
this.init = function () {

    // Clears canvas
    self.clearCanvas();

    // Adds a click event listeners to the 'Run' button
    $('.run-button').click(function () {
        // Clears canvas
        self.clearCanvas();

        // Runs algorithm
        self.run();
    });

    // Adds a click event listener to the 'Reset' button
    $('.reset-button').click(function () {
        self.clearCanvas();
    });

    // Adds click event listeners to all the 'Example' buttons
    $('.example-button').click(function () {
        self.loadExample($(this).attr('number'));
    });

    $('.pause-button').click(function () {

    });

};

// Clears canvas of all rendered elements
this.clearCanvas = function () {
    // Clears the drawing canvas of any preiously rendered elements
    self.$canvas.clearCanvas();
};

// Loads pre-configured examples into the inputs
this.loadExample = function (example) {
    this.clearCanvas();
    this.outputString('');

    // Gets a reference to the input textarea
    var $inputTextarea = $('#' + self.inputTextareaId);

    // Pre-defined examples
    switch (example) {
        // All examples must follow the same format
        case '1':
            $inputTextarea.val('R: 3' + '\n' +
                'C: 3' + '\n' +
                'Nets: 5' + '\n' +
                '1 c1.p1 c3.p2' + '\n' +
                '2 c2.p1 c8.p1' + '\n' +
                '3 c4.p3 c9.p2' + '\n' +
                '4 c5.p2 c7.p3' + '\n' +
                '5 c1.p3 c6.p1');
            break;

        case '2':
            $inputTextarea.val('R: 4' + '\n' +
                'C: 4' + '\n' +
                'Nets: 10' + '\n' +
                '1 c1.p2 c2.p3' + '\n' +
                '2 c3.p1 c2.p2' + '\n' +
                '3 c12.p3 c9.p3' + '\n' +
                '4 c11.p1 c14.p2' + '\n' +
                '5 c12.p1 c6.p1' + '\n' +
                '6 c14.p2 c3.p2' + '\n' +
                '7 c14.p3 c8.p3' + '\n' +
                '8 c8.p3 c9.p2' + '\n' +
                '9 c3.p2 c13.p1' + '\n' +
                '10 c1.p1 c15.p1');
            break;

        case '3':
            $inputTextarea.val('R: 5' + '\n' +
                'C: 5' + '\n' +
                'Nets: 20' + '\n' +
                '1 c11.p2 c8.p2' + '\n' +
                '2 c12.p2 c16.p1' + '\n' +
                '3 c7.p3 c1.p1' + '\n' +
                '4 c6.p3 c22.p2' + '\n' +
                '5 c8.p1 c19.p1' + '\n' +
                '6 c5.p1 c21.p2' + '\n' +
                '7 c2.p3 c6.p2' + '\n' +
                '8 c4.p3 c21.p3' + '\n' +
                '9 c9.p2 c2.p2' + '\n' +
                '10 c17.p1 c5.p2' + '\n' +
                '11 c18.p2 c20.p1' + '\n' +
                '12 c16.p3 c15.p2' + '\n' +
                '13 c13.p1 c4.p1' + '\n' +
                '14 c13.p2 c7.p2' + '\n' +
                '15 c23.p1 c12.p3' + '\n' +
                '16 c1.p3 c23.p3' + '\n' +
                '17 c14.p2 c22.p3' + '\n' +
                '18 c20.p3 c23.p2' + '\n' +
                '19 c19.p2 c9.p1' + '\n' +
                '20 c14.p3 c17.p2');
            break;

        default:
            $inputTextarea.val('');
    }

};

// Gets the indexOf an object in an array that has a property
Array.prototype.objectIndexOf = function (searchTerm, property) {
    for (var i = 0, len = this.length; i < len; i++) {
        if (this[i][property] === searchTerm) return i;
    }
    return -1;
};

// Shuffles an array and the ordering
Array.prototype.shuffle = function () {
    var input = this;

    for (var i = input.length - 1; i >= 0; i--) {

        var randomIndex = Math.floor(Math.random() * (i + 1));
        var itemAtIndex = input[randomIndex];

        input[randomIndex] = input[i];
        input[i] = itemAtIndex;
    }
    return input;
}

// Reads input and returns an array of objects
this.readInputs = function () {
    // Gets a reference to the input textarea
    var $inputTextArea = $('#' + self.inputTextareaId);

    // Stores all the lines parsed from the input area
    var lines = $inputTextArea.val().split('\n');

    /* Assumes that all input is formatted the same and considered valid */
    var rowSize = 0;
    var columnSize = 0;
    var netCount = 0;
    var netArray = new Array();

    // Parse input into an object containing the inputs and on-set values
    lines.forEach(function (line, index) {
        // Parse line into tokens
        var lineContents = line.split(/\s/g);

        // Checks for row/column/nets label
        switch (lineContents[0]) {
            case 'R:':
                rowSize = parseInt(lineContents[1]);
                break;
            case 'C:':
                columnSize = parseInt(lineContents[1]);
                break;
            case 'Nets:':
                netCount = parseInt(lineContents[1]);
                break;
            default:
                // Assume line is a net connection
                if (!isNaN(lineContents[0]) && lineContents.length == 3) {
                    netArray.push({
                        source: lineContents[1],
                        destination: lineContents[2]
                    });
                }
                break;
        };
    });

    // Checks if the input is parsable
    if (netCount <= 0 || netCount != netArray.length) {
        throw 'Parsing error.';
    } else {
        return {
            rows: rowSize,
            columns: columnSize,
            nets: netArray
        };
    }
};

// Prints contents to the output text area
this.outputString = function (string) {
    $('#' + self.outputTextareaId).html(string);
};

/*
	Takes in the |netList| array and create a cellOrder array containing all the connections
    returns an array of cell objects with default ordering C1-CN
*/
this.createCellOrder = function (rows, columns, netList) {
    var numberOfCells = rows * columns;
    var cellOrder = [];
    for (var i = 0; i < numberOfCells; i++) {
        cellOrder.push({
            label: 'c' + (i + 1),
            p1: '',
            p2: '',
            p3: '',
            marked: false // This is used for calculating the total manhattan distance
        });
    }

    netList.forEach(function (netConnection) {
        // Parse net connection for source and destination
        var sourceConnection = self.splitCellPort(netConnection.source);
        var destinationConnection = self.splitCellPort(netConnection.destination);

        // Find the indices for the two ends of the net
        var cellSourceIndex = cellOrder.objectIndexOf(sourceConnection.cell, 'label');
        var cellDestinationIndex = cellOrder.objectIndexOf(destinationConnection.cell, 'label');

        // Assign linkings between the two cells
        cellOrder[cellSourceIndex][sourceConnection.port] = netConnection.destination;
        cellOrder[cellDestinationIndex][destinationConnection.port] = netConnection.source;
    });

    return cellOrder;
};

/* 
	Draws the grid with the given information
      - rows:     Integer value specifying the number of cells in each row
      - columns:    Integer value specifying the number of cells in each column
      - cellOrder: An array of cell objects ordered by their position on the grid
   This function assumes that the grid is always printed left-to-right, top-to-bottom
*/
this.drawGrid = function (rows, columns, cellOrder) {
    var currentCellIndex = 0;
    var cellWidth = 100;
    var cellHeight = 100;
    var horizontalMargin = 30;
    var veritcalMargin = 30;

    var cellLabel = '-';
    for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
            // If grid is larger than cell orderings we want to display null cells
            if (currentCellIndex >= cellOrder.length) {
                cellLabel = '-';
            } else {
                cellLabel = cellOrder[currentCellIndex].label;
                currentCellIndex++;
            }

            self.$canvas.drawRect({
                fillStyle: 'white',
                strokeStyle: '#333333',
                strokeWidth: 2,
                x: (cellWidth * (j + 1)) - horizontalMargin,
                y: (cellHeight * (i + 1)) - veritcalMargin,
                width: cellWidth / 2,
                height: cellHeight / 2
            }).drawText({
                strokeStyle: '#333333',
                strokeWidth: 1,
                x: (cellWidth * (j + 1)) - horizontalMargin,
                y: (cellHeight * (i + 1)) - veritcalMargin,
                fontSize: 12,
                fontFamily: 'Helvetica, sans-serif',
                text: cellLabel
            }).drawText({
                strokeStyle: '#333333',
                strokeWidth: 1,
                x: (cellWidth * (j + 0.85)) - horizontalMargin,
                y: (cellHeight * (i + 0.8)) - veritcalMargin,
                fontSize: 9,
                fontFamily: 'Helvetica, sans-serif',
                text: 'p1'
            }).drawText({
                strokeStyle: '#333333',
                strokeWidth: 1,
                x: (cellWidth * (j + 1.0)) - horizontalMargin,
                y: (cellHeight * (i + 0.8)) - veritcalMargin,
                fontSize: 9,
                fontFamily: 'Helvetica, sans-serif',
                text: 'p2'
            }).drawText({
                strokeStyle: '#333333',
                strokeWidth: 1,
                x: (cellWidth * (j + 1.15)) - horizontalMargin,
                y: (cellHeight * (i + 0.8)) - veritcalMargin,
                fontSize: 9,
                fontFamily: 'Helvetica, sans-serif',
                text: 'p3'
            });
        }
    }
};

/*
	Takes in a |cellLabel| and returns the row + column that cell is located at
    	- cellLabel is expected to be a string that matches the label of a cell in cellOrder
    Returns a cellPosition objectain containing the row and column location of a cell
*/
this.findCellPosition = function (cellLabel, cellOrder, columns) {
    var cellIndex = cellOrder.objectIndexOf(cellLabel, 'label');
    var row = Math.floor(cellIndex / columns);
    var column = (cellIndex % columns);

    return {
        row: row,
        column: column
    };
};

/*
	Takes in two different |cellPositions| and returns the manhattan distance between them
    	- cellPosition1 & cellPosition2 are cell position objects with two properties (row, column)
    Returns the an integer containing the manhattan distance
*/
this.calculateManhattanDistance = function (cellPosition1, cellPosition2) {
    return Math.abs(cellPosition1.row - cellPosition2.row) + Math.abs(cellPosition1.column - cellPosition2.column);
};

/*
	Splits the port connections into an object containing the cell and port
    	|cellPort| is a stirng in the format [Cell].[port]
*/
this.splitCellPort = function (cellPort) {
    var cellAndPort = cellPort.split('.');

    // Cell labels should always be lowercased
    return {
        cell: cellAndPort[0].toLowerCase(),
        port: cellAndPort[1].toLowerCase()
    };
};

/*
	After the total wire length is calculated we want to unmark all traversed cells
*/
this.clearMarkedCells = function (cellOrder) {
    cellOrder.forEach(function (cell) {
        cell.marked = false;
    });

    return cellOrder;
};

/*
	Takes in |cellOrder| & |numberOfColumns| and calculates the total manhattan distance
    Returns total wire length
*/
this.getTotalWireLength = function (cellOrder, numberOfColumns) {
    var totalDistance = 0;
    cellOrder.forEach(function (cell) {
        if (!cell.marked) {
            // Mark cell as visited
            cell.marked = true;
            totalDistance += self.getCellDistance(cell, cellOrder, numberOfColumns);
        }
    });

    // After all wirelengths are computed we want to clear the markings
    self.clearMarkedCells(cellOrder);
    return totalDistance;
};

// Checks if a cell is marked as seen
this.isCellMarked = function (cellLabel, cellOrder) {
    return cellOrder[cellOrder.objectIndexOf(self.splitCellPort(cellLabel).cell, 'label')].marked;
};

/*
	Takes in a |cell| object, |numberOfColumns|, and |cellOrder|
    Returns the total distance of all the wires connected to the cell
*/
this.getCellDistance = function (cell, cellOrder, numberOfColumns) {
    var total = 0;
    // Check each port for a connection
    if (cell.p1 != '' && !self.isCellMarked(cell.p1, cellOrder)) {
        total += self.getDistanceBetweenCells(cell.label, self.splitCellPort(cell.p1).cell, cellOrder, numberOfColumns);
    }
    if (cell.p2 != '' && !self.isCellMarked(cell.p2, cellOrder)) {
        total += self.getDistanceBetweenCells(cell.label, self.splitCellPort(cell.p2).cell, cellOrder, numberOfColumns);
    }
    if (cell.p3 != '' && !self.isCellMarked(cell.p3, cellOrder)) {
        total += self.getDistanceBetweenCells(cell.label, self.splitCellPort(cell.p3).cell, cellOrder, numberOfColumns);
    }

    return total;
};

/*
	Calculates the distance between |cell1| and |cell2|
*/
this.getDistanceBetweenCells = function (cell1, cell2, cellOrder, numberOfColumns) {
    var startPos = self.findCellPosition(cell1, cellOrder, numberOfColumns);
    var endPos = self.findCellPosition(cell2, cellOrder, numberOfColumns);

    var cellWidth = 100;
    var cellHeight = 100;
    var horizontalMargin = 30;
    var veritcalMargin = 30;

    // Draws the manhattan distance between the two cells
    self.$canvas.drawLine({
        strokeStyle: '#CCCCCC',
        strokeWidth: 1,
        x1: (cellWidth * (startPos.column + 1)) - horizontalMargin,
        y1: (cellHeight * (startPos.row + 1)) - veritcalMargin,
        x2: (cellWidth * (startPos.column + 1)) - horizontalMargin,
        y2: (cellHeight * (endPos.row + 1)) - veritcalMargin,
        x3: (cellWidth * (endPos.column + 1)) - horizontalMargin,
        y3: (cellHeight * (endPos.row + 1)) - veritcalMargin
    });

    return Math.abs(startPos.row - endPos.row) + Math.abs(startPos.column - endPos.column);
};

/* 
	Creates the formatted event string for each iteration of SA
    T: 80, C: 50, C1-C8: 45, Accept
    T: |temperature|, C: |cost|, |swap|: |swapCost|, |actionTaken|
*/
this.createEventString = function (temperature, originalCost, swap, swapCost, actionTaken) {
    return 'T: ' + temperature + ' C: ' + originalCost + ' ' + swap + ': ' + swapCost + ', ' + actionTaken + '\n';
};

/*******************************************************************/
/* If you choose to create more functions please add them here     */

/*******************************************************************/
this.newdrawGrid = function (rows, columns, cellOrder, oldcellOrder) {
    var currentCellIndex = 0;
    var cellWidth = 100;
    var cellHeight = 100;
    var horizontalMargin = 30;
    var veritcalMargin = 30;

    var cellLabel = '-';
    for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
            // If grid is larger than cell orderings we want to display null cells
            var color = '#333333';
            if (currentCellIndex <= cellOrder.length) {
                cellLabel = cellOrder[currentCellIndex].label;
                if (cellOrder[currentCellIndex].label != oldcellOrder[currentCellIndex].label) {
                    color = '#BB0404';
                }
                currentCellIndex++;
            } else {
                cellLabel = '-';
            }

            self.$canvas.drawRect({
                fillStyle: 'white',
                strokeStyle: color,
                strokeWidth: 2,
                x: (cellWidth * (j + 1)) - horizontalMargin,
                y: (cellHeight * (i + 1)) - veritcalMargin,
                width: cellWidth / 2,
                height: cellHeight / 2
            }).drawText({
                strokeStyle: color,
                strokeWidth: 1,
                x: (cellWidth * (j + 1)) - horizontalMargin,
                y: (cellHeight * (i + 1)) - veritcalMargin,
                fontSize: 12,
                fontFamily: 'Helvetica, sans-serif',
                text: cellLabel
            }).drawText({
                strokeStyle: color,
                strokeWidth: 1,
                x: (cellWidth * (j + 0.85)) - horizontalMargin,
                y: (cellHeight * (i + 0.8)) - veritcalMargin,
                fontSize: 9,
                fontFamily: 'Helvetica, sans-serif',
                text: 'p1'
            }).drawText({
                strokeStyle: color,
                strokeWidth: 1,
                x: (cellWidth * (j + 1.0)) - horizontalMargin,
                y: (cellHeight * (i + 0.8)) - veritcalMargin,
                fontSize: 9,
                fontFamily: 'Helvetica, sans-serif',
                text: 'p2'
            }).drawText({
                strokeStyle: color,
                strokeWidth: 1,
                x: (cellWidth * (j + 1.15)) - horizontalMargin,
                y: (cellHeight * (i + 0.8)) - veritcalMargin,
                fontSize: 9,
                fontFamily: 'Helvetica, sans-serif',
                text: 'p3'
            });
        }
    }
};

// Runs your code
this.run = function () {
    this.clearCanvas();
    this.outputString('');

    // Declares an array variable to store wire connections
    var inputs;

    try {
        inputs = self.readInputs();
    } catch (error) {
        // Failed to parse input
        self.outputString(error);
        return;
    }

    // Takes in the input and create a cellOrder array
    var cellOrder = this.createCellOrder(inputs.rows, inputs.columns, inputs.nets);
    // Initially randomizes the placement
    cellOrder.shuffle();

    // Draws canvas remember to call this every time you decide to clear the canvas
    this.drawGrid(inputs.rows, inputs.columns, cellOrder);
    var initialTotalWireLength = this.getTotalWireLength(cellOrder, inputs.columns);

    // Simulated annealing settings
    var temperature = $('#temperatureInput').val();
    var cooling = $('#coolingRateInput').val();
    var moves = $('#movesInput').val();
    var frozen = $('#stopInput').val();
    var eventsString = '';

    /* Place your code here */
    var speed = $('#speedInput').val();

    var initialCostString = 'Initial cost: ' + initialTotalWireLength + '\n';
    var oldTotalWireLength = initialTotalWireLength;
    var action;
    var flag = 0;

    function whileloop() {
        // Real time adjustment of variables
        $('#temperatureInput').on('change', function () {
            temperature = $('#temperatureInput').val();
        });
        $('#coolingRateInput').on('change', function () {
            cooling = $('#coolingRateInput').val();
        });
        $('#movesInput').on('change', function () {
            moves = $('#movesInput').val();
        });
        $('#stopInput').on('change', function () {
            frozen = $('#stopInput').val();
        });
        $('#speedInput').on('change', function () {
            speed = $('#speedInput').val();
        });

        var move = 0;

        function forloop() {
            // Swap randomly
            var newcellOrder = $.extend(true, [], cellOrder);
            var l = newcellOrder.length;
            var randomIndex1 = Math.floor(Math.random() * (l));
            var randomIndex2 = Math.floor(Math.random() * (l));

            while (randomIndex1 == randomIndex2) {
                randomIndex2 = Math.floor(Math.random() * (l));
            }

            var itemAtIndex = newcellOrder[randomIndex1];
            newcellOrder[randomIndex1] = newcellOrder[randomIndex2];
            newcellOrder[randomIndex2] = itemAtIndex;
            // swap result: randomIndex1+1, randomIndex2+1
            var swap = newcellOrder[randomIndex1].label + '-' + newcellOrder[randomIndex2].label;
            // Compute cost (getTotalWireLength) difference
            var newTotalWireLength = this.getTotalWireLength(newcellOrder, inputs.columns);
            var C = oldTotalWireLength - newTotalWireLength;
            // cost difference: C
            if (C > 0) {
                // print action taken
                action = 'Accept';
                eventsString += this.createEventString(temperature, oldTotalWireLength, swap, newTotalWireLength, action);
                // draw the canvas
                this.clearCanvas();
                this.newdrawGrid(inputs.rows, inputs.columns, newcellOrder, cellOrder);
                var finalCost = this.getTotalWireLength(cellOrder, inputs.columns);
                var finalCostString = 'Final cost: ' + finalCost;
                this.outputString(initialCostString + eventsString + finalCostString);
                oldTotalWireLength = newTotalWireLength;
                // accept new solution
                cellOrder = newcellOrder;
            } else {
                //r = random number from 0 to 1
                var r = Math.random();
                var m = 1 / Math.pow(Math.E, Math.abs(C / temperature));
                if (r < m) {
                    // print action taken
                    action = 'Accept';
                    eventsString += this.createEventString(temperature, oldTotalWireLength, swap, newTotalWireLength, action);
                    this.clearCanvas();
                    this.newdrawGrid(inputs.rows, inputs.columns, newcellOrder, cellOrder);
                    var finalCost = this.getTotalWireLength(cellOrder, inputs.columns);
                    var finalCostString = 'Final cost: ' + finalCost;
                    this.outputString(initialCostString + eventsString + finalCostString);
                    oldTotalWireLength = newTotalWireLength;
                    // accept new solution
                    cellOrder = newcellOrder;
                } else {
                    // print action taken
                    action = 'Reject';
                    eventsString += this.createEventString(temperature, oldTotalWireLength, swap, newTotalWireLength, action);
                    var finalCost = this.getTotalWireLength(cellOrder, inputs.columns);
                    var finalCostString = 'Final cost: ' + finalCost;
                    this.outputString(initialCostString + eventsString + finalCostString);
                }
            }
            move++;
            if (move < moves) {
                setTimeout(forloop, speed);
            } else {
                var finalCost = this.getTotalWireLength(cellOrder, inputs.columns);
                var finalCostString = 'Final cost: ' + finalCost;
                this.outputString(initialCostString + eventsString + finalCostString);
            }
        }
        forloop();
        if (move == 1 && temperature == $('#temperatureInput').val() && flag == 0) {
            flag = 1;
            setTimeout(whileloop, moves * speed + 100);
            return;
        }
        temperature = temperature * (1 - cooling / 100);
        if (temperature * (1 - cooling / 100) - frozen > 0) {
            setTimeout(whileloop, moves * speed + 100);
        } else return;
    }
    whileloop();
    $('#pausebutton').click(function () {
        alert("Click to continue");
    });

    /* Delete this code this is just example code for how to create a long string of events */
    //eventsString = this.createEventString(80, 50, 'C1-C8', 45, 'Accept');
    //var initialCostString = 'Initial cost: ' + initialTotalWireLength + '\n';
    var finalCost = this.getTotalWireLength(cellOrder, inputs.columns);
    var finalCostString = 'Final cost: ' + finalCost;
    this.outputString(initialCostString + eventsString + finalCostString);
};

// Initializes listeners and resets any values
this.init();
/*
Based on the heuristic, only change some of the structure to utilize setTimeout to provide delay between iterations.
For detail implementation there are comments before every important step
forloop() does one iteration, whileloop() does one temperature.
Tasks:
1. Working Simulated Annealing heuristic - √
2. Output printed and drawn at each iteration - √ (delay added between iterations) change speed input tu alternate delay
3. Messaging for accepting or rejecting - √
4. Use different colors to indicate cells swapped - √
5. Realtime adjustment of speed and simulated annealing parameters - √
6. Pause function using alert() - √

(#28 is a work version using setInterval)
Project link:
https://jsfiddle.net/iEason/p4xxxz3s/37/
*/
});//]]> 

</script>

  
</head>

<body>
  <button number="1" class="example-button">Example 1</button>
<button number="2" class="example-button">Example 2</button>
<button number="3" class="example-button">Example 3</button>
<table>
    <tbody><tr>
        <td>Temperature:</td>
        <td>
            <input type="number" value="100" id="temperatureInput">
        </td>
    </tr>
    <tr>
        <td>Cooling rate:</td>
        <td>
            <input type="number" value="10" id="coolingRateInput">
        </td>
    </tr>
    <tr>
        <td>Number of moves per temperature:</td>
        <td>
            <input type="number" value="20" id="movesInput">
        </td>
    </tr>
    <tr>
        <td>Frozen(stop) temperature:</td>
        <td>
            <input type="number" value="10" id="stopInput">
        </td>
    </tr>
    <tr>
        <td>Delay between iteration:(ms)</td>
        <td>
            <input type="number" value="250" id="speedInput">
        </td>
    </tr>
    <tr>
        <td> <span class="container-label">Inputs:</span> 
            <textarea id="inputData" class="textarea-style"></textarea>
        </td>
        <td> <span class="container-label">Output:</span> 
            <textarea id="outputData" class="textarea-style textarea-wide"></textarea>
        </td>
    </tr>
</tbody></table>
<div class="button-container">
    <button class="run-button">Run</button>
    <button class="reset-button">Reset</button>
    <button class="pause-button" id="pausebutton">Pause</button>
</div> <span class="container-label">Canvas:</span> 
<div id="assignmentContainer" class="assignment-container">
    <canvas id="drawingCanvas" height="500" width="800"></canvas>
</div>
  
  <script>
  // tell the embed parent frame the height of the content
  if (window.parent && window.parent.parent){
    window.parent.parent.postMessage(["resultsFrame", {
      height: document.body.getBoundingClientRect().height,
      slug: "p4xxxz3s"
    }], "*")
  }
</script>

</body></html>
